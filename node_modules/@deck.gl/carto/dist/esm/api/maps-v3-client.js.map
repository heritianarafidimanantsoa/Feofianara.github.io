{"version":3,"sources":["../../../src/api/maps-v3-client.ts"],"names":["getDefaultCredentials","buildMapsUrlFromBase","buildStatsUrlFromBase","API_VERSIONS","COLUMNS_SUPPORT","encodeParameter","FORMATS","GEO_COLUMN_SUPPORT","MAP_TYPES","REQUEST_TYPES","TILE_FORMATS","CartoAPIError","parseMap","log","assert","MAX_GET_LENGTH","DEFAULT_CLIENT","V3_MINOR_VERSION","request","method","url","headers","customHeaders","accessToken","body","errorContext","Accept","Authorization","fetch","error","requestJson","response","json","ok","requestData","format","NDJSON","data","rows","getParameters","type","source","geoColumn","columns","clientId","aggregationExp","aggregationResLevel","queryParameters","filters","parameters","client","v","sourceName","QUERY","geo_column","join","isSpatialIndexGeoColumn","spatialIndex","split","mapInstantiation","connection","credentials","baseUrl","mapsUrl","encodedParameters","Object","entries","map","key","value","JSON","stringify","requestType","INSTANTIATION","length","getUrlFromMetadata","metadata","m","checkFetchLayerDataParameters","apiVersion","V3","apiBaseUrl","includes","TABLE","fetchLayerData","formatTiles","mapFormat","_fetchDataUrl","DATA","result","schema","defaultCredentials","localCreds","prioritizedFormats","GEOJSON","TILEJSON","f","values","_fetchMapDataset","dataset","connectionName","cache","parseInt","URL","searchParams","get","_fetchTilestats","attribute","statsUrl","TILE_STATS","stats","q","attributes","tilestats","layers","index","findIndex","d","fillInMapDatasets","datasets","token","promises","Promise","all","fillInTileStats","keplerMapConfig","config","visState","layer","channel","keys","visualChannels","name","find","id","dataId","TILESET","push","filteredAttributes","a","fetchMap","cartoMapId","autoRefresh","onNewData","PUBLIC_MAP","mapId","stopAutoRefresh","intervalId","setInterval","changed","some","clearInterval","geojsonLayers","filter","geojsonDatasetIds","forEach","geojson","out","textLayers","pointType","props","window","FontFace","document","fonts","check","font","load","then","add"],"mappings":"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","sourcesContent":["/**\n * Maps API Client for Carto 3\n */\nimport {\n  getDefaultCredentials,\n  buildMapsUrlFromBase,\n  buildStatsUrlFromBase,\n  CloudNativeCredentials\n} from '../config';\nimport {\n  API_VERSIONS,\n  COLUMNS_SUPPORT,\n  encodeParameter,\n  Format,\n  FORMATS,\n  GEO_COLUMN_SUPPORT,\n  MapInstantiation,\n  MapType,\n  MAP_TYPES,\n  QueryParameters,\n  REQUEST_TYPES,\n  SchemaField,\n  TileFormat,\n  TILE_FORMATS,\n  Filters\n} from './maps-api-common';\n\nimport {APIErrorContext, CartoAPIError} from './carto-api-error';\n\nimport {parseMap} from './parseMap';\nimport {log} from '@deck.gl/core';\nimport {assert} from '../utils';\n\nconst MAX_GET_LENGTH = 8192;\nconst DEFAULT_CLIENT = 'deck-gl-carto';\nconst V3_MINOR_VERSION = '3.2';\n\nexport type Headers = Record<string, string>;\ninterface RequestParams {\n  method?: string;\n  url: string;\n  headers?: Headers;\n  accessToken?: string;\n  body?: any;\n  errorContext: APIErrorContext;\n}\n\n/**\n * Request against Maps API\n */\nasync function request({\n  method,\n  url,\n  headers: customHeaders,\n  accessToken,\n  body,\n  errorContext\n}: RequestParams): Promise<Response> {\n  const headers: Headers = {\n    ...customHeaders,\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    /* global fetch */\n    return await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new CartoAPIError(error as Error, errorContext);\n  }\n}\n\nasync function requestJson<T = unknown>({\n  method,\n  url,\n  headers,\n  accessToken,\n  body,\n  errorContext\n}: RequestParams): Promise<T> {\n  const response = await request({method, url, headers, accessToken, body, errorContext});\n  let json;\n  try {\n    json = await response.json();\n  } catch (error) {\n    json = {error: ''};\n  }\n\n  if (!response.ok) {\n    throw new CartoAPIError(json.error, errorContext, response);\n  }\n  return json as T;\n}\n\nasync function requestData({\n  method,\n  url,\n  accessToken,\n  format,\n  body,\n  errorContext\n}: RequestParams & {\n  format: Format;\n}): Promise<Response | unknown> {\n  if (format === FORMATS.NDJSON) {\n    return request({method, url, accessToken, body, errorContext});\n  }\n\n  const data = await requestJson<any>({method, url, accessToken, body, errorContext});\n  return data.rows ? data.rows : data;\n}\n\ntype FetchLayerDataParams = {\n  type: MapType;\n  source: string;\n  connection: string;\n  credentials: CloudNativeCredentials;\n  geoColumn?: string;\n  columns?: string[];\n  clientId?: string;\n  format?: Format;\n  formatTiles?: TileFormat;\n  headers?: Headers;\n  aggregationExp?: string;\n  aggregationResLevel?: number;\n  queryParameters?: QueryParameters;\n  filters?: Filters;\n};\n\ntype MapsAPIParameters = {\n  client: string;\n  v: string;\n  q?: string;\n  name?: string;\n  queryParameters?: QueryParameters;\n  geo_column?: string;\n  columns?: string;\n  aggregationExp?: string;\n  aggregationResLevel?: number;\n  filters?: Filters;\n};\n\n/**\n * Build a URL with all required parameters\n */\nfunction getParameters({\n  type,\n  source,\n  geoColumn,\n  columns,\n  clientId,\n  aggregationExp,\n  aggregationResLevel,\n  queryParameters,\n  filters\n}: Omit<FetchLayerDataParams, 'connection' | 'credentials'>): MapsAPIParameters {\n  const parameters: MapsAPIParameters = {\n    client: clientId || DEFAULT_CLIENT,\n    v: V3_MINOR_VERSION\n  };\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters[sourceName] = source;\n\n  if (queryParameters) {\n    parameters.queryParameters = queryParameters;\n  }\n\n  if (geoColumn) {\n    parameters.geo_column = geoColumn;\n  }\n  if (columns) {\n    parameters.columns = columns.join(',');\n  }\n  if (aggregationExp) {\n    parameters.aggregationExp = aggregationExp;\n  } else if (isSpatialIndexGeoColumn(geoColumn)) {\n    // Default aggregationExp required for spatial index layers\n    parameters.aggregationExp = '1 AS value';\n  }\n  if (aggregationResLevel) {\n    parameters.aggregationResLevel = aggregationResLevel;\n  }\n  if (filters) {\n    parameters.filters = filters;\n  }\n\n  return parameters;\n}\n\nfunction isSpatialIndexGeoColumn(geoColumn: string | undefined) {\n  const spatialIndex = geoColumn?.split(':')[0];\n  return spatialIndex === 'h3' || spatialIndex === 'quadbin';\n}\n\nexport async function mapInstantiation({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  clientId,\n  headers,\n  aggregationExp,\n  aggregationResLevel,\n  queryParameters,\n  filters\n}: FetchLayerDataParams): Promise<MapInstantiation> {\n  const baseUrl = `${credentials.mapsUrl}/${connection}/${type}`;\n  const parameters = getParameters({\n    type,\n    source,\n    geoColumn,\n    columns,\n    clientId,\n    aggregationResLevel,\n    aggregationExp,\n    queryParameters,\n    filters\n  });\n  const encodedParameters = Object.entries(parameters).map(([key, value]) => {\n    if (typeof value !== 'string') {\n      value = JSON.stringify(value);\n    }\n    return encodeParameter(key, value);\n  });\n  const url = `${baseUrl}?${encodedParameters.join('&')}`;\n  const {accessToken} = credentials;\n\n  const errorContext = {requestType: REQUEST_TYPES.INSTANTIATION, connection, type, source};\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    return await requestJson({\n      method: 'POST',\n      url: baseUrl,\n      headers,\n      accessToken,\n      body: JSON.stringify(parameters),\n      errorContext\n    });\n  }\n\n  return await requestJson({url, headers, accessToken, errorContext});\n}\n\nfunction getUrlFromMetadata(metadata: MapInstantiation, format: Format): string | null {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  aggregationExp,\n  aggregationResLevel,\n  filters\n}: FetchLayerDataParams) {\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n\n  if (columns) {\n    assert(\n      COLUMNS_SUPPORT.includes(type),\n      `The columns parameter is not supported by type ${type}`\n    );\n  }\n  if (geoColumn) {\n    assert(\n      GEO_COLUMN_SUPPORT.includes(type),\n      `The geoColumn parameter is not supported by type ${type}`\n    );\n  } else {\n    assert(!aggregationExp, 'Have aggregationExp, but geoColumn parameter is missing');\n    assert(!aggregationResLevel, 'Have aggregationResLevel, but geoColumn parameter is missing');\n  }\n  if (filters) {\n    assert(\n      type === MAP_TYPES.TABLE || type === MAP_TYPES.QUERY,\n      'The filters parameter is only supported by type table and query'\n    );\n  }\n}\n\nexport interface FetchLayerDataResult {\n  data: any;\n  format?: Format;\n  schema: SchemaField[];\n}\nexport async function fetchLayerData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  clientId,\n  headers,\n  aggregationExp,\n  aggregationResLevel,\n  queryParameters,\n  filters\n}: FetchLayerDataParams): Promise<FetchLayerDataResult> {\n  // Internally we split data fetching into two parts to allow us to\n  // conditionally fetch the actual data, depending on the metadata state\n  const {url, accessToken, mapFormat, metadata} = await _fetchDataUrl({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    clientId,\n    headers,\n    aggregationExp,\n    aggregationResLevel,\n    queryParameters,\n    filters\n  });\n\n  const errorContext = {requestType: REQUEST_TYPES.DATA, connection, type, source};\n  const data = await requestData({url, format: mapFormat, accessToken, errorContext});\n  const result: FetchLayerDataResult = {data, format: mapFormat, schema: metadata.schema};\n  return result;\n}\n\nasync function _fetchDataUrl({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  clientId,\n  headers,\n  aggregationExp,\n  aggregationResLevel,\n  queryParameters,\n  filters\n}: FetchLayerDataParams) {\n  const defaultCredentials = getDefaultCredentials();\n  // Only pick up default credentials if they have been defined for\n  // correct API version\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkFetchLayerDataParameters({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    aggregationExp,\n    aggregationResLevel,\n    filters\n  });\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    clientId,\n    headers,\n    aggregationExp,\n    aggregationResLevel,\n    queryParameters,\n    filters\n  });\n  let url: string | null = null;\n  let mapFormat: Format | undefined;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    assert(url, `Format ${format} not available`);\n  } else {\n    // guess map format\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n    assert(url && mapFormat, 'Unsupported data formats received from backend.');\n  }\n\n  if (format === FORMATS.TILEJSON && formatTiles) {\n    log.assert(\n      Object.values(TILE_FORMATS).includes(formatTiles),\n      `Invalid value for formatTiles: ${formatTiles}. Use value from TILE_FORMATS`\n    );\n    url += `&${encodeParameter('formatTiles', formatTiles)}`;\n  }\n\n  const {accessToken} = localCreds;\n  return {url, accessToken, mapFormat, metadata};\n}\n\n/* global clearInterval, setInterval, URL */\nasync function _fetchMapDataset(\n  dataset,\n  accessToken: string,\n  credentials: CloudNativeCredentials,\n  clientId?: string,\n  headers?: Headers\n) {\n  const {\n    aggregationExp,\n    aggregationResLevel,\n    connectionName: connection,\n    columns,\n    format,\n    geoColumn,\n    source,\n    type,\n    queryParameters\n  } = dataset;\n  // First fetch metadata\n  const {url, mapFormat} = await _fetchDataUrl({\n    aggregationExp,\n    aggregationResLevel,\n    clientId,\n    credentials: {...credentials, accessToken},\n    connection,\n    columns,\n    format,\n    geoColumn,\n    headers,\n    source,\n    type,\n    queryParameters\n  });\n\n  // Extract the last time the data changed\n  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n  if (cache && dataset.cache === cache) {\n    return false;\n  }\n  dataset.cache = cache;\n\n  // Only fetch if the data has changed\n  const errorContext = {requestType: REQUEST_TYPES.DATA, connection, type, source};\n  dataset.data = await requestData({url, format: mapFormat, accessToken, errorContext});\n\n  return true;\n}\n\nasync function _fetchTilestats(\n  attribute,\n  dataset,\n  accessToken: string,\n  credentials: CloudNativeCredentials\n) {\n  const {connectionName: connection, source, type} = dataset;\n\n  const statsUrl = buildStatsUrlFromBase(credentials.apiBaseUrl);\n  let baseUrl = `${statsUrl}/${connection}/`;\n  if (type === MAP_TYPES.QUERY) {\n    baseUrl += attribute;\n  } else {\n    // MAP_TYPE.TABLE\n    baseUrl += `${source}/${attribute}`;\n  }\n\n  const errorContext = {requestType: REQUEST_TYPES.TILE_STATS, connection, type, source};\n  let url = baseUrl;\n  if (type === MAP_TYPES.QUERY) {\n    url += `?${encodeParameter('q', source)}`;\n  }\n  let stats;\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    stats = await requestJson({\n      method: 'POST',\n      url: baseUrl,\n      accessToken,\n      body: JSON.stringify({q: source}),\n      errorContext\n    });\n  } else {\n    stats = await requestJson({url, accessToken, errorContext});\n  }\n\n  // Replace tilestats for attribute with value from API\n  const {attributes} = dataset.data.tilestats.layers[0];\n  const index = attributes.findIndex(d => d.attribute === attribute);\n  attributes[index] = stats;\n  return true;\n}\n\nasync function fillInMapDatasets(\n  {datasets, token},\n  clientId: string,\n  credentials: CloudNativeCredentials,\n  headers?: Headers\n) {\n  const promises = datasets.map(dataset =>\n    _fetchMapDataset(dataset, token, credentials, clientId, headers)\n  );\n  return await Promise.all(promises);\n}\n\nasync function fillInTileStats(\n  {datasets, keplerMapConfig, token},\n  credentials: CloudNativeCredentials\n) {\n  const attributes: {attribute?: string; dataset?: any}[] = [];\n  const {layers} = keplerMapConfig.config.visState;\n  for (const layer of layers) {\n    for (const channel of Object.keys(layer.visualChannels)) {\n      const attribute = layer.visualChannels[channel]?.name;\n      if (attribute) {\n        const dataset = datasets.find(d => d.id === layer.config.dataId);\n        if (dataset.data.tilestats && dataset.type !== MAP_TYPES.TILESET) {\n          // Only fetch stats for QUERY & TABLE map types\n          attributes.push({attribute, dataset});\n        }\n      }\n    }\n  }\n  // Remove duplicates to avoid repeated requests\n  const filteredAttributes: {attribute?: string; dataset?: any}[] = [];\n  for (const a of attributes) {\n    if (\n      !filteredAttributes.find(\n        ({attribute, dataset}) => attribute === a.attribute && dataset === a.dataset\n      )\n    ) {\n      filteredAttributes.push(a);\n    }\n  }\n\n  const promises = filteredAttributes.map(({attribute, dataset}) =>\n    _fetchTilestats(attribute, dataset, token, credentials)\n  );\n  return await Promise.all(promises);\n}\n\n/* eslint-disable max-statements */\nexport async function fetchMap({\n  cartoMapId,\n  clientId,\n  credentials,\n  headers,\n  autoRefresh,\n  onNewData\n}: {\n  cartoMapId: string;\n  clientId: string;\n  credentials?: CloudNativeCredentials;\n  headers?: Headers;\n  autoRefresh?: number;\n  onNewData?: (map: any) => void;\n}) {\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  } as CloudNativeCredentials;\n  const {accessToken} = localCreds;\n\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n\n  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(\n      typeof autoRefresh === 'number' && autoRefresh > 0,\n      '`autoRefresh` must be a positive number'\n    );\n  }\n\n  const url = `${localCreds.mapsUrl}/public/${cartoMapId}`;\n  const errorContext = {requestType: REQUEST_TYPES.PUBLIC_MAP, mapId: cartoMapId};\n  const map = await requestJson<any>({url, headers, accessToken, errorContext});\n\n  // Periodically check if the data has changed. Note that this\n  // will not update when a map is published.\n  let stopAutoRefresh: (() => void) | undefined;\n  if (autoRefresh) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, clientId, localCreds, headers);\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(\n    ({type}) => type === 'geojson' || type === 'point'\n  );\n  const geojsonDatasetIds = geojsonLayers.map(({config}) => config.dataId);\n  map.datasets.forEach(dataset => {\n    if (geojsonDatasetIds.includes(dataset.id)) {\n      const {config} = geojsonLayers.find(({config}) => config.dataId === dataset.id);\n      dataset.format = 'geojson';\n      // Support for very old maps. geoColumn was not stored in the past\n      if (!dataset.geoColumn && config.columns.geojson) {\n        dataset.geoColumn = config.columns.geojson;\n      }\n    }\n  });\n\n  // Mutates map.datasets so that dataset.data contains data\n  await fillInMapDatasets(map, clientId, localCreds, headers);\n\n  // Mutates attributes in visualChannels to contain tile stats\n  await fillInTileStats(map, localCreds);\n  const out = {...parseMap(map), ...{stopAutoRefresh}};\n\n  const textLayers = out.layers.filter(layer => {\n    const pointType = layer.props.pointType || '';\n    return pointType.includes('text');\n  });\n\n  /* global FontFace, window, document */\n  if (textLayers.length && window.FontFace && !document.fonts.check('12px Inter')) {\n    // Fetch font needed for labels\n    const font = new FontFace(\n      'Inter',\n      'url(https://fonts.gstatic.com/s/inter/v12/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7W0Q5nw.woff2)'\n    );\n    await font.load().then(f => document.fonts.add(f));\n  }\n\n  return out;\n}\n"],"file":"maps-v3-client.js"}