"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/pbf/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/pbf/node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module) {
      "use strict";
      module.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        },
        readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val, b;
          b = buf[this.pos++];
          val = b & 127;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 7;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 14;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 21;
          if (b < 128)
            return val;
          b = buf[this.pos];
          val |= (b & 15) << 28;
          return readVarintRemainder(val, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val) {
          var type = val & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min) {
          var length = this.length || 16;
          while (length < this.pos + min)
            length *= 2;
          if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = val >>> 7 & 127;
        },
        writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },
        writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len = buffer.length;
          this.writeVarint(len);
          this.realloc(len);
          for (var i = 0; i < len; i++)
            this.buf[this.pos++] = buffer[i];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val);
        },
        writeSFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val);
        },
        writeFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val);
        },
        writeSFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val);
        },
        writeVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val);
        },
        writeSVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val);
        },
        writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val);
        },
        writeDoubleField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val);
        },
        writeBooleanField: function(tag, val) {
          this.writeVarintField(tag, Boolean(val));
        }
      };
      function readVarintRemainder(l, s, p) {
        var buf = p.buf, h, b;
        b = buf[p.pos++];
        h = (b & 112) >> 4;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 3;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 10;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 17;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 24;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 1) << 31;
        if (b < 128)
          return toNum(l, h, s);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        var low, high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len, pbf) {
        var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i = pbf.pos - 1; i >= startPos; i--)
          pbf.buf[i + extraLen] = pbf.buf[i];
      }
      function writePackedVarint(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeVarint(arr[i]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeSVarint(arr[i]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeFloat(arr[i]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeDouble(arr[i]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeBoolean(arr[i]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeFixed32(arr[i]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeSFixed32(arr[i]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeFixed64(arr[i]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeSFixed64(arr[i]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i = pos;
        while (i < end) {
          var b0 = buf[i];
          var c = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i = 0, c, lead; i < str.length; i++) {
          c = str.charCodeAt(i);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              } else {
                c = lead - 55296 << 10 | c - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c > 56319 || i + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // ../../node_modules/tilebelt/index.js
  var require_tilebelt = __commonJS({
    "../../node_modules/tilebelt/index.js"(exports, module) {
      var d2r = Math.PI / 180;
      var r2d = 180 / Math.PI;
      function tileToBBOX(tile) {
        var e = tile2lon(tile[0] + 1, tile[2]);
        var w = tile2lon(tile[0], tile[2]);
        var s = tile2lat(tile[1] + 1, tile[2]);
        var n = tile2lat(tile[1], tile[2]);
        return [w, s, e, n];
      }
      function tileToGeoJSON(tile) {
        var bbox = tileToBBOX(tile);
        var poly = {
          type: "Polygon",
          coordinates: [
            [
              [bbox[0], bbox[1]],
              [bbox[0], bbox[3]],
              [bbox[2], bbox[3]],
              [bbox[2], bbox[1]],
              [bbox[0], bbox[1]]
            ]
          ]
        };
        return poly;
      }
      function tile2lon(x, z) {
        return x / Math.pow(2, z) * 360 - 180;
      }
      function tile2lat(y, z) {
        var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
        return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
      }
      function pointToTile(lon, lat, z) {
        var tile = pointToTileFraction(lon, lat, z);
        tile[0] = Math.floor(tile[0]);
        tile[1] = Math.floor(tile[1]);
        return tile;
      }
      function getChildren(tile) {
        return [
          [tile[0] * 2, tile[1] * 2, tile[2] + 1],
          [tile[0] * 2 + 1, tile[1] * 2, tile[2] + 1],
          [tile[0] * 2 + 1, tile[1] * 2 + 1, tile[2] + 1],
          [tile[0] * 2, tile[1] * 2 + 1, tile[2] + 1]
        ];
      }
      function getParent(tile) {
        if (tile[0] % 2 === 0 && tile[1] % 2 === 0) {
          return [tile[0] / 2, tile[1] / 2, tile[2] - 1];
        } else if (tile[0] % 2 === 0 && !tile[1] % 2 === 0) {
          return [tile[0] / 2, (tile[1] - 1) / 2, tile[2] - 1];
        } else if (!tile[0] % 2 === 0 && tile[1] % 2 === 0) {
          return [(tile[0] - 1) / 2, tile[1] / 2, tile[2] - 1];
        } else {
          return [(tile[0] - 1) / 2, (tile[1] - 1) / 2, tile[2] - 1];
        }
      }
      function getSiblings(tile) {
        return getChildren(getParent(tile));
      }
      function hasSiblings(tile, tiles2) {
        var siblings = getSiblings(tile);
        for (var i = 0; i < siblings.length; i++) {
          if (!hasTile(tiles2, siblings[i]))
            return false;
        }
        return true;
      }
      function hasTile(tiles2, tile) {
        for (var i = 0; i < tiles2.length; i++) {
          if (tilesEqual(tiles2[i], tile))
            return true;
        }
        return false;
      }
      function tilesEqual(tile1, tile2) {
        return tile1[0] === tile2[0] && tile1[1] === tile2[1] && tile1[2] === tile2[2];
      }
      function tileToQuadkey(tile) {
        var index = "";
        for (var z = tile[2]; z > 0; z--) {
          var b = 0;
          var mask = 1 << z - 1;
          if ((tile[0] & mask) !== 0)
            b++;
          if ((tile[1] & mask) !== 0)
            b += 2;
          index += b.toString();
        }
        return index;
      }
      function quadkeyToTile(quadkey) {
        var x = 0;
        var y = 0;
        var z = quadkey.length;
        for (var i = z; i > 0; i--) {
          var mask = 1 << i - 1;
          switch (quadkey[z - i]) {
            case "0":
              break;
            case "1":
              x |= mask;
              break;
            case "2":
              y |= mask;
              break;
            case "3":
              x |= mask;
              y |= mask;
              break;
          }
        }
        return [x, y, z];
      }
      function bboxToTile(bboxCoords) {
        var min = pointToTile(bboxCoords[0], bboxCoords[1], 32);
        var max = pointToTile(bboxCoords[2], bboxCoords[3], 32);
        var bbox = [min[0], min[1], max[0], max[1]];
        var z = getBboxZoom(bbox);
        if (z === 0)
          return [0, 0, 0];
        var x = bbox[0] >>> 32 - z;
        var y = bbox[1] >>> 32 - z;
        return [x, y, z];
      }
      function getBboxZoom(bbox) {
        var MAX_ZOOM = 28;
        for (var z = 0; z < MAX_ZOOM; z++) {
          var mask = 1 << 32 - (z + 1);
          if ((bbox[0] & mask) != (bbox[2] & mask) || (bbox[1] & mask) != (bbox[3] & mask)) {
            return z;
          }
        }
        return MAX_ZOOM;
      }
      function pointToTileFraction(lon, lat, z) {
        var sin = Math.sin(lat * d2r), z2 = Math.pow(2, z), x = z2 * (lon / 360 + 0.5), y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
        return [x, y, z];
      }
      module.exports = {
        tileToGeoJSON,
        tileToBBOX,
        getChildren,
        getParent,
        getSiblings,
        hasTile,
        hasSiblings,
        tilesEqual,
        tileToQuadkey,
        quadkeyToTile,
        pointToTile,
        bboxToTile,
        pointToTileFraction
      };
    }
  });

  // ../../node_modules/@mapbox/tile-cover/index.js
  var require_tile_cover = __commonJS({
    "../../node_modules/@mapbox/tile-cover/index.js"(exports) {
      var tilebelt = require_tilebelt();
      exports.geojson = function(geom, limits) {
        return {
          type: "FeatureCollection",
          features: getTiles(geom, limits).map(tileToFeature)
        };
      };
      function tileToFeature(t) {
        return {
          type: "Feature",
          geometry: tilebelt.tileToGeoJSON(t),
          properties: {}
        };
      }
      exports.tiles = getTiles;
      exports.indexes = function(geom, limits) {
        return getTiles(geom, limits).map(tilebelt.tileToQuadkey);
      };
      function getTiles(geom, limits) {
        var i, tile, coords = geom.coordinates, maxZoom = limits.max_zoom, tileHash = {}, tiles2 = [];
        if (geom.type === "Point") {
          return [tilebelt.pointToTile(coords[0], coords[1], maxZoom)];
        } else if (geom.type === "MultiPoint") {
          for (i = 0; i < coords.length; i++) {
            tile = tilebelt.pointToTile(coords[i][0], coords[i][1], maxZoom);
            tileHash[toID(tile[0], tile[1], tile[2])] = true;
          }
        } else if (geom.type === "LineString") {
          lineCover(tileHash, coords, maxZoom);
        } else if (geom.type === "MultiLineString") {
          for (i = 0; i < coords.length; i++) {
            lineCover(tileHash, coords[i], maxZoom);
          }
        } else if (geom.type === "Polygon") {
          polygonCover(tileHash, tiles2, coords, maxZoom);
        } else if (geom.type === "MultiPolygon") {
          for (i = 0; i < coords.length; i++) {
            polygonCover(tileHash, tiles2, coords[i], maxZoom);
          }
        } else {
          throw new Error("Geometry type not implemented");
        }
        if (limits.min_zoom !== maxZoom) {
          var len = tiles2.length;
          appendHashTiles(tileHash, tiles2);
          for (i = 0; i < len; i++) {
            var t = tiles2[i];
            tileHash[toID(t[0], t[1], t[2])] = true;
          }
          return mergeTiles(tileHash, tiles2, limits);
        }
        appendHashTiles(tileHash, tiles2);
        return tiles2;
      }
      function mergeTiles(tileHash, tiles2, limits) {
        var mergedTiles = [];
        for (var z = limits.max_zoom; z > limits.min_zoom; z--) {
          var parentTileHash = {};
          var parentTiles = [];
          for (var i = 0; i < tiles2.length; i++) {
            var t = tiles2[i];
            if (t[0] % 2 === 0 && t[1] % 2 === 0) {
              var id2 = toID(t[0] + 1, t[1], z), id3 = toID(t[0], t[1] + 1, z), id4 = toID(t[0] + 1, t[1] + 1, z);
              if (tileHash[id2] && tileHash[id3] && tileHash[id4]) {
                tileHash[toID(t[0], t[1], t[2])] = false;
                tileHash[id2] = false;
                tileHash[id3] = false;
                tileHash[id4] = false;
                var parentTile = [t[0] / 2, t[1] / 2, z - 1];
                if (z - 1 === limits.min_zoom)
                  mergedTiles.push(parentTile);
                else {
                  parentTileHash[toID(t[0] / 2, t[1] / 2, z - 1)] = true;
                  parentTiles.push(parentTile);
                }
              }
            }
          }
          for (i = 0; i < tiles2.length; i++) {
            t = tiles2[i];
            if (tileHash[toID(t[0], t[1], t[2])])
              mergedTiles.push(t);
          }
          tileHash = parentTileHash;
          tiles2 = parentTiles;
        }
        return mergedTiles;
      }
      function polygonCover(tileHash, tileArray, geom, zoom) {
        var intersections = [];
        for (var i = 0; i < geom.length; i++) {
          var ring = [];
          lineCover(tileHash, geom[i], zoom, ring);
          for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
            var m = (j + 1) % len;
            var y = ring[j][1];
            if ((y > ring[k][1] || y > ring[m][1]) && (y < ring[k][1] || y < ring[m][1]) && y !== ring[m][1])
              intersections.push(ring[j]);
          }
        }
        intersections.sort(compareTiles);
        for (i = 0; i < intersections.length; i += 2) {
          y = intersections[i][1];
          for (var x = intersections[i][0] + 1; x < intersections[i + 1][0]; x++) {
            var id2 = toID(x, y, zoom);
            if (!tileHash[id2]) {
              tileArray.push([x, y, zoom]);
            }
          }
        }
      }
      function compareTiles(a, b) {
        return a[1] - b[1] || a[0] - b[0];
      }
      function lineCover(tileHash, coords, maxZoom, ring) {
        var prevX, prevY;
        for (var i = 0; i < coords.length - 1; i++) {
          var start = tilebelt.pointToTileFraction(coords[i][0], coords[i][1], maxZoom), stop = tilebelt.pointToTileFraction(coords[i + 1][0], coords[i + 1][1], maxZoom), x0 = start[0], y0 = start[1], x1 = stop[0], y1 = stop[1], dx = x1 - x0, dy = y1 - y0;
          if (dy === 0 && dx === 0)
            continue;
          var sx = dx > 0 ? 1 : -1, sy = dy > 0 ? 1 : -1, x = Math.floor(x0), y = Math.floor(y0), tMaxX = dx === 0 ? Infinity : Math.abs(((dx > 0 ? 1 : 0) + x - x0) / dx), tMaxY = dy === 0 ? Infinity : Math.abs(((dy > 0 ? 1 : 0) + y - y0) / dy), tdx = Math.abs(sx / dx), tdy = Math.abs(sy / dy);
          if (x !== prevX || y !== prevY) {
            tileHash[toID(x, y, maxZoom)] = true;
            if (ring && y !== prevY)
              ring.push([x, y]);
            prevX = x;
            prevY = y;
          }
          while (tMaxX < 1 || tMaxY < 1) {
            if (tMaxX < tMaxY) {
              tMaxX += tdx;
              x += sx;
            } else {
              tMaxY += tdy;
              y += sy;
            }
            tileHash[toID(x, y, maxZoom)] = true;
            if (ring && y !== prevY)
              ring.push([x, y]);
            prevX = x;
            prevY = y;
          }
        }
        if (ring && y === ring[0][1])
          ring.pop();
      }
      function appendHashTiles(hash, tiles2) {
        var keys = Object.keys(hash);
        for (var i = 0; i < keys.length; i++) {
          tiles2.push(fromID(+keys[i]));
        }
      }
      function toID(x, y, z) {
        var dim = 2 * (1 << z);
        return (dim * y + x) * 32 + z;
      }
      function fromID(id2) {
        var z = id2 % 32, dim = 2 * (1 << z), xy = (id2 - z) / 32, x = xy % dim, y = (xy - x) / dim % dim;
        return [x, y, z];
      }
    }
  });

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
  function getTransferList(object) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let transfers = arguments.length > 2 ? arguments[2] : void 0;
    const transfersSet = transfers || /* @__PURE__ */ new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && typeof object === "object") {
      for (const key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js
  function getParentPort() {
    let parentPort;
    try {
      eval("globalThis.parentPort = require('worker_threads').parentPort");
      parentPort = globalThis.parentPort;
    } catch {
    }
    return parentPort;
  }
  var onMessageWrapperMap = /* @__PURE__ */ new Map();
  var WorkerBody = class {
    static inWorkerThread() {
      return typeof self !== "undefined" || Boolean(getParentPort());
    }
    static set onmessage(onMessage) {
      function handleMessage(message) {
        const parentPort3 = getParentPort();
        const {
          type,
          payload
        } = parentPort3 ? message : message.data;
        onMessage(type, payload);
      }
      const parentPort2 = getParentPort();
      if (parentPort2) {
        parentPort2.on("message", handleMessage);
        parentPort2.on("exit", () => console.debug("Node worker closing"));
      } else {
        globalThis.onmessage = handleMessage;
      }
    }
    static addEventListener(onMessage) {
      let onMessageWrapper = onMessageWrapperMap.get(onMessage);
      if (!onMessageWrapper) {
        onMessageWrapper = (message) => {
          if (!isKnownMessage(message)) {
            return;
          }
          const parentPort3 = getParentPort();
          const {
            type,
            payload
          } = parentPort3 ? message : message.data;
          onMessage(type, payload);
        };
      }
      const parentPort2 = getParentPort();
      if (parentPort2) {
        console.error("not implemented");
      } else {
        globalThis.addEventListener("message", onMessageWrapper);
      }
    }
    static removeEventListener(onMessage) {
      const onMessageWrapper = onMessageWrapperMap.get(onMessage);
      onMessageWrapperMap.delete(onMessage);
      const parentPort2 = getParentPort();
      if (parentPort2) {
        console.error("not implemented");
      } else {
        globalThis.removeEventListener("message", onMessageWrapper);
      }
    }
    static postMessage(type, payload) {
      const data = {
        source: "loaders.gl",
        type,
        payload
      };
      const transferList = getTransferList(payload);
      const parentPort2 = getParentPort();
      if (parentPort2) {
        parentPort2.postMessage(data, transferList);
      } else {
        globalThis.postMessage(data, transferList);
      }
    }
  };
  function isKnownMessage(message) {
    const {
      type,
      data
    } = message;
    return type === "message" && data && typeof data.source === "string" && data.source.startsWith("loaders.gl");
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js
  var requestId = 0;
  function createLoaderWorker(loader) {
    if (!WorkerBody.inWorkerThread()) {
      return;
    }
    WorkerBody.onmessage = async (type, payload) => {
      switch (type) {
        case "process":
          try {
            const {
              input,
              options = {},
              context = {}
            } = payload;
            const result = await parseData({
              loader,
              arrayBuffer: input,
              options,
              context: {
                ...context,
                parse: parseOnMainThread
              }
            });
            WorkerBody.postMessage("done", {
              result
            });
          } catch (error) {
            const message = error instanceof Error ? error.message : "";
            WorkerBody.postMessage("error", {
              error: message
            });
          }
          break;
        default:
      }
    };
  }
  function parseOnMainThread(arrayBuffer, options) {
    return new Promise((resolve, reject) => {
      const id2 = requestId++;
      const onMessage = (type, payload2) => {
        if (payload2.id !== id2) {
          return;
        }
        switch (type) {
          case "done":
            WorkerBody.removeEventListener(onMessage);
            resolve(payload2.result);
            break;
          case "error":
            WorkerBody.removeEventListener(onMessage);
            reject(payload2.error);
            break;
          default:
        }
      };
      WorkerBody.addEventListener(onMessage);
      const payload = {
        id: id2,
        input: arrayBuffer,
        options
      };
      WorkerBody.postMessage("process", payload);
    });
  }
  async function parseData(_ref) {
    let {
      loader,
      arrayBuffer,
      options,
      context
    } = _ref;
    let data;
    let parser;
    if (loader.parseSync || loader.parse) {
      data = arrayBuffer;
      parser = loader.parseSync || loader.parse;
    } else if (loader.parseTextSync) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(arrayBuffer);
      parser = loader.parseTextSync;
    } else {
      throw new Error("Could not load data with ".concat(loader.name, " loader"));
    }
    options = {
      ...options,
      modules: loader && loader.options && loader.options.modules || {},
      worker: false
    };
    return await parser(data, {
      ...options
    }, context, loader);
  }

  // src/layers/schema/fast-pbf.ts
  function readPackedTypedArray(TypedArray, pbf, obj) {
    const end = pbf.type === 2 ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    obj.value = new TypedArray(pbf.buf.buffer.slice(pbf.pos, end));
    pbf.pos = end;
    return obj.value;
  }

  // src/layers/schema/carto-tile.ts
  var KeyValueObjectReader = class {
    static read(pbf, end) {
      return pbf.readFields(KeyValueObjectReader._readField, { key: "", value: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.key = pbf.readString();
      else if (tag === 2)
        obj.value = pbf.readString();
    }
  };
  var PropertiesReader = class {
    static read(pbf, end) {
      return pbf.readFields(PropertiesReader._readField, {}, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1) {
        const { key, value } = KeyValueObjectReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj[key] = value;
      }
    }
  };
  var NumericPropReader = class {
    static read(pbf, end) {
      return pbf.readFields(NumericPropReader._readField, { value: [] }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        readPackedTypedArray(Float64Array, pbf, obj);
    }
  };
  var NumericPropKeyValueReader = class {
    static read(pbf, end) {
      return pbf.readFields(NumericPropKeyValueReader._readField, { key: "", value: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.key = pbf.readString();
      else if (tag === 2)
        obj.value = NumericPropReader.read(pbf, pbf.readVarint() + pbf.pos);
    }
  };

  // src/layers/schema/carto-spatial-tile.ts
  var IndicesReader = class {
    static read(pbf, end) {
      return pbf.readFields(IndicesReader._readField, { value: [] }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        readPackedTypedArray(BigUint64Array, pbf, obj);
    }
  };
  var CellsReader = class {
    static read(pbf, end) {
      return pbf.readFields(
        CellsReader._readField,
        { indices: null, properties: [], numericProps: {} },
        end
      );
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.indices = IndicesReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 2)
        obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
      else if (tag === 3) {
        const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj.numericProps[entry.key] = entry.value;
      }
    }
  };
  var TileReader = class {
    static read(pbf, end) {
      return pbf.readFields(TileReader._readField, { scheme: 0, cells: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.scheme = pbf.readVarint();
      else if (tag === 2)
        obj.cells = CellsReader.read(pbf, pbf.readVarint() + pbf.pos);
    }
  };

  // src/layers/schema/tile-loader-utils.ts
  var import_pbf = __toESM(require_pbf());
  function parsePbf(buffer, TileReader2) {
    const pbf = new import_pbf.default(buffer);
    const tile = TileReader2.read(pbf);
    return tile;
  }

  // src/utils.ts
  function getWorkerUrl(id2, version) {
    return `https://unpkg.com/@deck.gl/carto@${version}/dist/${id2}-worker.js`;
  }

  // ../../node_modules/quadbin/dist/esm/index.js
  var import_tile_cover = __toESM(require_tile_cover());
  function bigIntToHex(index) {
    return index.toString(16);
  }

  // src/layers/schema/spatialjson-utils.ts
  function binaryToSpatialjson(binary) {
    const { cells, scheme } = binary;
    const count = cells.indices.value.length;
    const spatial = [];
    for (let i = 0; i < count; i++) {
      const id2 = scheme === "h3" ? bigIntToHex(cells.indices.value[i]) : cells.indices.value[i];
      const properties = { ...cells.properties[i] };
      for (const key of Object.keys(cells.numericProps)) {
        properties[key] = cells.numericProps[key].value[i];
      }
      spatial.push({ id: id2, properties });
    }
    return spatial;
  }

  // src/layers/schema/carto-spatial-tile-loader.ts
  var VERSION = true ? "8.9.33" : "latest";
  var id = "cartoSpatialTile";
  var DEFAULT_OPTIONS = {
    cartoSpatialTile: {
      scheme: "quadbin",
      workerUrl: getWorkerUrl(id, VERSION)
    }
  };
  var CartoSpatialTileLoader = {
    name: "CARTO Spatial Tile",
    version: VERSION,
    id,
    module: "carto",
    extensions: ["pbf"],
    mimeTypes: ["application/vnd.carto-spatial-tile"],
    category: "geometry",
    parse: async (arrayBuffer, options) => parseCartoSpatialTile(arrayBuffer, options),
    parseSync: parseCartoSpatialTile,
    worker: true,
    options: DEFAULT_OPTIONS
  };
  function parseCartoSpatialTile(arrayBuffer, options) {
    if (!arrayBuffer)
      return null;
    const tile = parsePbf(arrayBuffer, TileReader);
    const { cells } = tile;
    const scheme = options?.cartoSpatialTile?.scheme;
    const data = { cells, scheme };
    return binaryToSpatialjson(data);
  }
  var carto_spatial_tile_loader_default = CartoSpatialTileLoader;

  // src/workers/cartoSpatialTile.ts
  createLoaderWorker(carto_spatial_tile_loader_default);
})();
